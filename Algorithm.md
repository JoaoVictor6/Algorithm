
1. **Round Robin** - Algoritmo de escalonamento em sistemas operacionais, onde cada processo recebe uma quantidade de tempo igual para execução em uma ordem circular.
2. **First-Come, First-Served (FCFS)** - Processos são atendidos na ordem em que chegam.
3. **Shortest Job Next (SJN)** - O processo com o menor tempo de execução é selecionado para execução.
4. **Priority Scheduling** - Cada processo é atribuído a uma prioridade e o processo com a maior prioridade é selecionado para execução.
5. **Multilevel Queue Scheduling** - Processos são divididos em diferentes filas baseadas em prioridade, e cada fila tem seu próprio algoritmo de escalonamento.
6. **Multilevel Feedback Queue Scheduling** - Similar ao Multilevel Queue, mas permite que processos se movam entre filas com base em seu comportamento e tempo de execução.
7. **Earliest Deadline First (EDF)** - Utilizado em sistemas de tempo real, onde o processo com o prazo mais próximo é selecionado para execução.
8. **Bubble Sort** - Algoritmo simples de ordenação que compara e troca elementos adjacentes repetidamente.
9. **Selection Sort** - Encontra o menor elemento na lista e o move para a posição correta, repetidamente.
10. **Insertion Sort** - Constrói a lista ordenada de um elemento por vez, inserindo elementos na posição correta.
11. **Merge Sort** - Algoritmo de ordenação baseado na técnica de dividir e conquistar.
12. **Quick Sort** - Outro algoritmo de dividir e conquistar que seleciona um pivô e particiona a lista em duas sublistas.
13. **Heap Sort** - Utiliza uma estrutura de dados chamada heap para ordenar elementos.
14. **Counting Sort** - Algoritmo de ordenação não comparativo, adequado para listas com valores limitados a um intervalo específico.

### Semana 3: Algoritmos de Busca
15. **Linear Search** - Busca um elemento na lista comparando-o sequencialmente com cada elemento.
16. **Binary Search** - Busca um elemento em uma lista ordenada dividindo repetidamente a lista ao meio.
17. **Depth-First Search (DFS)** - Algoritmo de busca em grafos que explora o máximo possível ao longo de cada ramificação antes de retroceder.
18. **Breadth-First Search (BFS)** - Algoritmo de busca em grafos que explora todos os vizinhos de um vértice antes de passar para os vizinhos dos vizinhos.
19. **Jump Search** - Algoritmo de busca em listas ordenadas que salta blocos de elementos para encontrar o valor alvo.
20. **Exponential Search** - Combina a busca binária e a busca exponencial para encontrar rapidamente um intervalo para a busca binária.
21. **Interpolation Search** - Busca em listas ordenadas que estima a posição do valor alvo baseado em uma fórmula de interpolação.

### Semana 4: Algoritmos em Grafos
22. **Dijkstra's Algorithm** - Encontra o caminho mais curto de um vértice para todos os outros vértices em um grafo com pesos não negativos.
23. **Bellman-Ford Algorithm** - Encontra o caminho mais curto de um vértice para todos os outros, permitindo pesos negativos.
24. **Floyd-Warshall Algorithm** - Encontra os caminhos mais curtos entre todos os pares de vértices em um grafo.
25. **Kruskal's Algorithm** - Encontra a árvore geradora mínima em um grafo conectando todos os vértices com o menor custo possível.
26. **Prim's Algorithm** - Outro algoritmo para encontrar a árvore geradora mínima começando a partir de um vértice específico.
27. **A* Algorithm** - Algoritmo de busca de caminho que usa heurísticas para encontrar o caminho mais curto, frequentemente usado em jogos e IA.
28. **Topological Sort** - Ordenação dos vértices de um grafo direcionado acíclico de tal forma que para cada aresta u -> v, u vem antes de v na ordenação.

### Semana 5: Algoritmos de Programação Dinâmica
29. **Fibonacci Sequence** - Cálculo de números de Fibonacci usando programação dinâmica.
30. **Knapsack Problem** - Algoritmo para resolver o problema da mochila utilizando programação dinâmica.
31. **Longest Common Subsequence (LCS)** - Encontra a subsequência comum mais longa entre duas sequências.
32. **Matrix Chain Multiplication** - Determina a ordem ótima para multiplicar uma cadeia de matrizes.
33. **Edit Distance (Levenshtein Distance)** - Calcula a menor distância de edição entre duas strings.
34. **Coin Change Problem** - Determina a menor quantidade de moedas necessária para fazer uma quantia específica.
35. **Partition Problem** - Verifica se uma dada coleção de números pode ser particionada em duas partes com somas iguais.

Essa lista cobre uma ampla variedade de algoritmos fundamentais que são úteis em diversas áreas da ciência da computação. Cada dia, você pode estudar a teoria por trás do algoritmo, analisar exemplos de implementação e resolver alguns problemas práticos para reforçar o conhecimento. Boa sorte nos estudos!